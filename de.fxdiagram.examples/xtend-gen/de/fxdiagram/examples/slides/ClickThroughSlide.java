package de.fxdiagram.examples.slides;

import de.fxdiagram.annotations.properties.ModelNode;
import de.fxdiagram.core.extensions.DurationExtensions;
import de.fxdiagram.core.model.ModelElementImpl;
import de.fxdiagram.core.model.ToString;
import de.fxdiagram.examples.slides.RevealBehavior;
import de.fxdiagram.examples.slides.Slide;
import java.util.function.Consumer;
import javafx.animation.FadeTransition;
import javafx.collections.ObservableList;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.shape.Rectangle;
import javafx.util.Duration;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ObjectExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@ModelNode
@SuppressWarnings("all")
public class ClickThroughSlide extends Slide {
  private Pane pane;
  
  private Node currentNode;
  
  public ClickThroughSlide(final String name) {
    super(name);
  }
  
  public ClickThroughSlide(final String name, final Image backgroundImage) {
    super(name, backgroundImage);
  }
  
  @Override
  public void initializeGraphics() {
    super.initializeGraphics();
    final Procedure1<Pane> _function = (Pane it) -> {
      ObservableList<Node> _children = it.getChildren();
      Iterable<Node> _tail = IterableExtensions.<Node>tail(_children);
      final Consumer<Node> _function_1 = (Node it_1) -> {
        it_1.setOpacity(0);
      };
      _tail.forEach(_function_1);
    };
    ObjectExtensions.<Pane>operator_doubleArrow(
      this.pane, _function);
    ObservableList<Node> _children = this.pane.getChildren();
    Node _head = IterableExtensions.<Node>head(_children);
    this.currentNode = _head;
  }
  
  @Override
  protected StackPane createNode() {
    StackPane _xblockexpression = null;
    {
      final StackPane node = super.createNode();
      ObservableList<Node> _children = node.getChildren();
      Pane _pane = new Pane();
      Pane _pane_1 = (this.pane = _pane);
      _children.add(_pane_1);
      _xblockexpression = node;
    }
    return _xblockexpression;
  }
  
  @Override
  public void doActivate() {
    super.doActivate();
    Scene _scene = this.getScene();
    double _width = _scene.getWidth();
    Scene _scene_1 = this.getScene();
    double _height = _scene_1.getHeight();
    Rectangle _rectangle = new Rectangle(0, 0, _width, _height);
    this.pane.setClip(_rectangle);
    RevealBehavior _revealBehavior = new RevealBehavior(this);
    this.addBehavior(_revealBehavior);
  }
  
  public FadeTransition getRevealTransition(final Node childNode) {
    FadeTransition _fadeTransition = new FadeTransition();
    final Procedure1<FadeTransition> _function = (FadeTransition it) -> {
      it.setNode(childNode);
      it.setFromValue(0);
      it.setToValue(1);
      Duration _millis = DurationExtensions.millis(200);
      it.setDuration(_millis);
    };
    return ObjectExtensions.<FadeTransition>operator_doubleArrow(_fadeTransition, _function);
  }
  
  public boolean next() {
    final ObservableList<Node> children = this.pane.getChildren();
    boolean _isEmpty = children.isEmpty();
    if (_isEmpty) {
      return false;
    } else {
      int _indexOf = children.indexOf(this.currentNode);
      final int nextIndex = (_indexOf + 1);
      int _size = children.size();
      boolean _equals = (nextIndex == _size);
      if (_equals) {
        return false;
      }
      Node _get = children.get(nextIndex);
      this.currentNode = _get;
      FadeTransition _revealTransition = this.getRevealTransition(this.currentNode);
      _revealTransition.play();
      return true;
    }
  }
  
  public boolean previous() {
    final ObservableList<Node> children = this.pane.getChildren();
    boolean _isEmpty = children.isEmpty();
    if (_isEmpty) {
      return false;
    } else {
      int _indexOf = children.indexOf(this.currentNode);
      final int previousIndex = (_indexOf - 1);
      if ((previousIndex < 0)) {
        return false;
      }
      this.currentNode.setOpacity(0);
      Node _get = children.get(previousIndex);
      this.currentNode = _get;
      return true;
    }
  }
  
  public Pane getPane() {
    return this.pane;
  }
  
  /**
   * Automatically generated by @ModelNode. Needed for deserialization.
   */
  public ClickThroughSlide() {
  }
  
  public void populate(final ModelElementImpl modelElement) {
    super.populate(modelElement);
  }
  
  public void postLoad() {
    
  }
  
  public String toString() {
    return ToString.toString(this);
  }
}
